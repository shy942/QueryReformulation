data binding separate time type information observable observation usages observables programmatic usage observable created client code methods invoked directly main benefit data binding library situation ability use standard content providers utilities transformations needed use case client code type observable elements abstract usage client code sets bindings things interact observables directly client use observables unique identifiers obtain factory pass directly framework method selects correct binding client code rarely methods directly observable case aren mutually exclusive app likely use observables ways common use cases complicates usage needed usage goal simplify usage restricting usage way suggestion data type called observable handle returns observable interface observable handle observable observable object value type remove element type method observable set value type method observable value situation information needed observable wrapped observable handle returned observable handle value type observable factory return observable handle observable method makes decisions based type observable data binding context bind observable handle observable argument impact client using purely usage little difference working observables working observable handles obtains observable factory available implementing observable using usage write simpler code common currency concrete observable interfaces observable handle possible mix match obtained observable handle factory wanted use programmatically downcasting observable handle observable instantiated concrete observable wanted pass method expects observable handle easily wrap observable handle scripting languages obtain observables factories available autoboxing
 